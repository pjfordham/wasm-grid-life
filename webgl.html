<!doctype html>
<html>
   <body>
      <canvas width = "1000" height = "1000" id = "canvas"></canvas>

      <script>
         /* Step1: Prepare the canvas and get WebGL context */

         var canvas = document.getElementById('canvas');
         var gl = canvas.getContext('webgl');


        /* Step2: Define the geometry and store it in buffer objects */

        var vertices = [
            -0.5,-0.5,0.0,
            -0.25,0.5,0.0,
            0.0,-0.5,0.0,

            0.0,-0.5,0.0,
            0.25,0.5,0.0,
            0.5,-0.5,0.0,

            -0.25,0.5,0.0,
            0.0,-0.5,0.0,
            0.25,0.5,0.0,
        ];

        var indices = [0,1,2,3,4,5,6,7,8];

        var colors = [ 0,0,1, 0,0,1, 0,0,1,
                       1,0,0, 1,0,0, 1,0,0,
                      0,1,0, 0,1,0, 0,1,0 ];


         // Create the vertex buffer ( this is all the verticies )
         var vertex_buffer = gl.createBuffer();

         // Bind an empty array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Pass the vertices data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);


        // Create the index buffer ( this is the order in which to visit the vertices to draw the triangles )
        var index_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer)
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);


        // Create the color buffer, each vertex has a specific color
        var color_buffer = gl.createBuffer ();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);


        /* Step3: Create and compile Shader programs */

         // Vertex shader source code
         var vertCode =
             'attribute vec3 color;' + // Import a vector of triplets called color
             'varying vec3 vColor;' +  // Export a vector of triplets called vColor
             'uniform mat4 u_xformMatrix;' +  // Import a matrix 4x4
             'attribute vec4 coordinates;' +  // Import vector of cordinates x4
             'void main(void) {' +
             'gl_Position = u_xformMatrix * coordinates;' + // Apply matrix transform to positions
             'vColor = color;' + // explot color to fragment shader
             '}';

         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);


        // Fragment shader source code
        var fragCode =
            'precision mediump float;' + // Dunno?
            'varying vec3 vColor;' +  // Import the vColor vector from vertex shader
            'void main(void) {' +
            'gl_FragColor = vec4(vColor, 1);'+ // Apply color to fragment + 1 alpha
            '}';

         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragment shader
         gl.compileShader(fragShader);


        // Create a shader program object to store combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);


        /* Step 4: Associate the shader programs to buffer objects */

         //Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer)

         //Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         //point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

         //Enable the attribute
         gl.enableVertexAttribArray(coord);


        // Can we down the above and index the colors as well?
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
        //Get the attribute location
         var color = gl.getAttribLocation(shaderProgram, "color");
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 0, 0);
         gl.enableVertexAttribArray(color);


   function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8]; 

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];
            m[1] = c*m[1]+s*mv0;
            m[5] = c*m[5]+s*mv4;
            m[9] = c*m[9]+s*mv8;
   }

        // Transformation matrix
        var Sx = 1.5, Sy = 1.0, Sz = 1.0;
         var xformMatrix = new Float32Array([
            Sx,   0.0,  0.0,  0.0,
            0.0,  Sy,   0.0,  0.0,
            0.0,  0.0,  Sz,   0.0,
            0.0,  0.0,  0.0,  1.0
         ]);

        // Push down to shader
        var u_xformMatrix = gl.getUniformLocation(shaderProgram, 'u_xformMatrix');

        /* Step5: Drawing the required object (triangle) */

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

        var time_old = 0;
         var animate = function(time) {
            var dt = time-time_old;
            time_old = time;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            rotateZ(xformMatrix, dt*0.001);
            gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            window.requestAnimationFrame(animate);
         }
         animate(0);

      </script>
   </body>
</html>
